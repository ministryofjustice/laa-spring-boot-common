buildscript {
    repositories {
        mavenCentral()
    }
    dependencies {
        classpath 'org.yaml:snakeyaml:2.2'
    }
}

def exportControllerConfigFiles = [
    project.file('src/main/resources/application.yml'),
    project.file('src/main/resources/application.yaml')
]
def exportDefinitionsDir = project.file('src/main/resources/export_definitions')
def exportDefinitionFiles = project.fileTree(exportDefinitionsDir) {
    include '**/*.yml'
    include '**/*.yaml'
}
def exportControllerGeneratedDir = layout.buildDirectory.dir('generated/export-web')
def defaultGeneratedPackage = 'uk.gov.justice.laa.export.generated'

def loadExportsConfig = { yamlParser ->
    for (File file : exportControllerConfigFiles) {
        if (!file.exists()) {
            continue
        }
        def config = yamlParser.load(file.text) ?: [:]
        def exportsConfig = config?.laa?.springboot?.starter?.exports
        if (!exportsConfig) {
            exportsConfig = config?.laa?.'springboot.starter'?.exports
        }
        if (exportsConfig) {
            return exportsConfig
        }
    }
    return [:]
}

def filenameKey = { File file ->
    def name = file.name
    def dot = name.lastIndexOf('.')
    return dot > 0 ? name.substring(0, dot) : name
}

def loadDefinitionsFromFiles = { yamlParser ->
    def defs = [:]
    if (!exportDefinitionsDir.exists() || exportDefinitionFiles.isEmpty()) {
        return defs
    }
    exportDefinitionFiles.each { file ->
        def data = yamlParser.load(file.text) ?: [:]
        def nestedDefs = data?.laa?.springboot?.starter?.exports?.definitions ?: [:]
        if (!nestedDefs) {
            nestedDefs = data?.laa?.'springboot.starter'?.exports?.definitions ?: [:]
        }
        if (nestedDefs) {
            defs.putAll(nestedDefs)
            return
        }
        if (data?.sql || data?.provider) {
            defs.put(filenameKey(file), data)
            return
        }
        if (data instanceof Map && !data.isEmpty()) {
            defs.putAll(data)
        }
    }
    return defs
}

def extractAliases = { String sql ->
    def keys = []
    if (sql == null) {
        return keys
    }
    def matcher = (sql =~ /(?i)\bas\s+\"?([A-Za-z_][A-Za-z0-9_]*)\"?\s*(,|\bfrom\b|$)/)
    matcher.each { match -> keys << match[1] }
    return keys
}

def toCamel = { String value ->
    value.split(/[^A-Za-z0-9]+/).findAll { it }.collect { it.capitalize() }.join('')
}

tasks.register('generateExportControllers') {
    exportControllerConfigFiles.findAll { it.exists() }.each { inputs.file(it) }
    inputs.files(exportDefinitionFiles)
    outputs.dir(exportControllerGeneratedDir)
    doLast {
        def exportDir = exportControllerGeneratedDir.get().asFile
        exportDir.mkdirs()

        def yaml = new org.yaml.snakeyaml.Yaml()
        def exportsConfig = loadExportsConfig(yaml)
        if (exportsConfig?.enabled != true) {
            logger.warn('Exports disabled; skipping export controller generation.')
            return
        }

        def definitions = loadDefinitionsFromFiles(yaml)
        def appDefinitions = exportsConfig?.definitions ?: [:]
        definitions.putAll(appDefinitions)
        if (definitions.isEmpty()) {
            logger.warn('No export definitions found; skipping export controller generation.')
            return
        }

        definitions.each { key, defn ->
            def sql = defn?.sql
            if (!sql) {
                return
            }

            def packageName = defn.packageName ?: defaultGeneratedPackage
            def className = toCamel(key) + 'ExportController'
            def outDir = new File(exportDir, packageName.replace('.', '/'))
            outDir.mkdirs()

            def sb = new StringBuilder()
            sb << "package ${packageName};\n\n"
            sb << 'import io.swagger.v3.oas.annotations.Operation;\n'
            sb << 'import io.swagger.v3.oas.annotations.media.Content;\n'
            sb << 'import io.swagger.v3.oas.annotations.media.ExampleObject;\n'
            sb << 'import io.swagger.v3.oas.annotations.responses.ApiResponse;\n'
            sb << 'import java.time.LocalDate;\n'
            sb << 'import java.util.HashMap;\n'
            sb << 'import java.util.Map;\n'
            sb << 'import org.springframework.http.HttpHeaders;\n'
            sb << 'import org.springframework.http.ResponseEntity;\n'
            sb << 'import org.springframework.web.bind.annotation.GetMapping;\n'
            sb << 'import org.springframework.web.bind.annotation.RequestMapping;\n'
            sb << 'import org.springframework.web.bind.annotation.RequestParam;\n'
            sb << 'import org.springframework.web.bind.annotation.RestController;\n'
            sb << 'import org.springframework.web.servlet.mvc.method.annotation.StreamingResponseBody;\n'
            sb << 'import uk.gov.justice.laa.export.ExportService;\n\n'

            sb << '/**\n'
            sb << " * Generated export endpoint for ${key}.\n"
            sb << ' */\n'
            sb << '@RestController\n'
            sb << '@RequestMapping("${laa.springboot.starter.exports.web.base-path:/exports}")\n'
            sb << "public class ${className} {\n"
            sb << '  private final ExportService exportService;\n\n'
            sb << "  public ${className}(ExportService exportService) {\n"
            sb << '    this.exportService = exportService;\n'
            sb << '  }\n\n'

            def params = defn?.params ?: []
            def columns = defn?.columns ?: []
            def aliasKeys = extractAliases(sql)
            def headerKeys = aliasKeys
            if (!columns.isEmpty()) {
                def columnKeys = columns.collect { it.key }
                if (!aliasKeys.isEmpty()) {
                    def missing = columnKeys.findAll { !aliasKeys.contains(it) }
                    headerKeys = aliasKeys + missing
                } else {
                    headerKeys = columnKeys
                }
            }

            def headerLine = ''
            if (!headerKeys.isEmpty()) {
                def overrides = [:]
                columns.each { c -> overrides[c.key] = c }
                def headers = []
                headerKeys.each { alias ->
                    def override = overrides[alias]
                    headers << (override?.header ?: alias)
                }
                headerLine = headers.join(',')
            }

            def methodName = 'export' + toCamel(key)
            sb << "  @Operation(summary = \"Export ${key}\")\n"
            if (headerLine) {
                def escaped = headerLine.replace('"', '\\"')
                def chunks = escaped.collect { it }.collate(80).collect { it.join('') }
                sb << '  @ApiResponse(\n'
                sb << '      responseCode = "200",\n'
                sb << '      description = "CSV export",\n'
                sb << '      content = @Content(\n'
                sb << '          mediaType = "text/csv",\n'
                sb << '          examples = @ExampleObject(\n'
                sb << '              value =\n'
                chunks.eachWithIndex { chunk, idx ->
                    def prefix = idx == 0 ? '                  ' : '                  + '
                    sb << "${prefix}\"${chunk}\"\n"
                }
                sb << '          )\n'
                sb << '      )\n'
                sb << '  )\n'
            } else {
                sb << '  @ApiResponse(\n'
                sb << '      responseCode = "200",\n'
                sb << '      description = "CSV export",\n'
                sb << '      content = @Content(mediaType = "text/csv")\n'
                sb << '  )\n'
            }

            sb << "  @GetMapping(value = \"/${key}.csv\", produces = \"text/csv\")\n"
            sb << "  public ResponseEntity<StreamingResponseBody> ${methodName}(\n"

            def requestParams = []
            params.each { p ->
                def required = p.required == true
                def requiredAttr = required ? '' : ', required = false'
                requestParams << "      @RequestParam(name = \"${p.name}\"${requiredAttr}) String ${p.name}"
            }
            sb << requestParams.join(',\n')
            sb << '\n  ) {\n'
            sb << '    Map<String, String[]> rawParams = new HashMap<>();\n'
            params.each { p ->
                sb << "    if (${p.name} != null) {\n"
                sb << "      rawParams.put(\"${p.name}\", new String[] { ${p.name} });\n"
                sb << '    }\n'
            }
            sb << "    String filename = \"${key}-\" + LocalDate.now() + \".csv\";\n"
            sb << "    StreamingResponseBody body = out -> exportService.streamCsv(\"${key}\", rawParams, out);\n"
            sb << '    return ResponseEntity.ok()\n'
            sb << '        .header(HttpHeaders.CONTENT_DISPOSITION, "attachment; filename=\\\"" + filename + "\\\"")\n'
            sb << '        .header(HttpHeaders.CACHE_CONTROL, "no-store")\n'
            sb << '        .body(body);\n'
            sb << '  }\n'
            sb << '}\n'

            new File(outDir, "${className}.java").text = sb.toString()
        }
    }
}

sourceSets.main.java.srcDirs += exportControllerGeneratedDir
compileJava.dependsOn tasks.named('generateExportControllers')
